package io.github.notsyncing.lightfur.entity

import kotlin.properties.ReadWriteProperty
import kotlin.reflect.KProperty

class EntityField<T>(val fieldType: Class<T>,
                     val column: String? = null,
                     val type: String = "",
                     val length: Int = 0,
                     val nullable: Boolean = false,
                     val defaultValue: T? = null,
                     val defaultValueDefinedInDatabase: Boolean = false,
                     val primaryKey: Boolean = false,
                     val autoGenerated: Boolean = false) : ReadWriteProperty<EntityModel, T> {
    var data: Any? = null
        get() = field
        set(value) {
            changed = field != value
            field = value
        }

    var changed = false

    lateinit var info: EntityFieldInfo

    override fun getValue(thisRef: EntityModel, property: KProperty<*>): T {
        return data as T
    }

    override fun setValue(thisRef: EntityModel, property: KProperty<*>, value: T) {
        changed = data != value
        data = value
    }

    operator fun provideDelegate(thisRef: EntityModel, property: KProperty<*>): ReadWriteProperty<EntityModel, T> {
        val propertyName = property.name
        var inner = EntityGlobal.fieldInfoInners[thisRef::class.java]!![propertyName]

        if (inner == null) {
            inner = EntityFieldInfo.Inner(property.name, column ?: property.name, type, length, nullable, defaultValue,
                    defaultValueDefinedInDatabase, primaryKey, autoGenerated)
            EntityGlobal.fieldInfoInners[thisRef::class.java]!![propertyName] = inner
        }

        info = EntityFieldInfo(thisRef, inner)

        if (primaryKey) {
            val l = EntityModel.getPrimaryKeyFieldsFromCache(thisRef::class.java as Class<EntityModel>)
            l.add(property)
            thisRef.primaryKeyFieldInfos.add(info)
            thisRef.primaryKeyFields = l
        }

        thisRef.fieldMap[propertyName] = this

        return this
    }
}
