package io.github.notsyncing.lightfur.entity

import kotlin.properties.ReadOnlyProperty
import kotlin.properties.ReadWriteProperty
import kotlin.reflect.KProperty
import kotlin.reflect.KProperty0
import kotlin.reflect.KProperty1

class EntityField<T>(val fieldType: Class<T>,
                     val column: String? = null,
                     val type: String = "",
                     val length: Int = 0,
                     val nullable: Boolean = false,
                     val defaultValue: String = "",
                     val primaryKey: Boolean = false,
                     val autoGenerated: Boolean = false) : ReadWriteProperty<EntityModel, T> {
    var data: Any? = null
        get() = field
        set(value) {
            field = value
            changed = true
        }

    var changed = false

    private lateinit var propertyRef: KProperty<*>

    lateinit var info: EntityFieldInfo

    override fun getValue(thisRef: EntityModel, property: KProperty<*>): T {
        return data as T
    }

    override fun setValue(thisRef: EntityModel, property: KProperty<*>, value: T) {
        data = value
        changed = true
    }

    operator fun provideDelegate(thisRef: EntityModel, property: KProperty<*>): ReadWriteProperty<EntityModel, T> {
        propertyRef = property

        val propertyName = property.name
        var inner = EntityGlobal.fieldInfoInners[thisRef.javaClass]!![propertyName]

        if (inner == null) {
            inner = EntityFieldInfo.Inner(property.name, column ?: property.name, type, length, nullable, defaultValue,
                    primaryKey, autoGenerated)
            EntityGlobal.fieldInfoInners[thisRef.javaClass]!![propertyName] = inner
        }

        info = EntityFieldInfo(thisRef, inner)

        if (primaryKey) {
            thisRef.primaryKeyFields.add(property)
            thisRef.primaryKeyFieldInfos.add(info)
        }

        thisRef.fieldMap[propertyName] = this

        return this
    }
}
