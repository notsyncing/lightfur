package io.github.notsyncing.lightfur.entity

import com.alibaba.fastjson.annotation.JSONField
import io.github.notsyncing.lightfur.entity.dsl.EntityDSL
import io.github.notsyncing.lightfur.entity.dsl.EntityInsertDSL
import io.github.notsyncing.lightfur.sql.models.TableModel
import java.util.*
import java.util.concurrent.ConcurrentHashMap
import kotlin.reflect.KProperty0

abstract class EntityModel(@JSONField(serialize = false, deserialize = false) val database: String? = null,
                           @JSONField(serialize = false, deserialize = false) val schema: String? = null,
                           @JSONField(serialize = false, deserialize = false) val table: String) {
    @JSONField(serialize = false, deserialize = false)
    val fieldMap = ConcurrentHashMap<String, EntityField<*>>()

    @JSONField(serialize = false, deserialize = false)
    val primaryKeyFields = ArrayList<KProperty0<*>>()

    @JSONField(serialize = false, deserialize = false)
    val primaryKeyFieldInfos = ArrayList<EntityFieldInfo>()

    init {
        if (!EntityGlobal.tableModels.containsKey(this.javaClass)) {
            val t = TableModel()
            t.name = table
            t.database = database
            t.schema = schema

            EntityGlobal.tableModels[this.javaClass] = t
        }

        if (!EntityGlobal.fieldInfoInners.containsKey(this.javaClass)) {
            EntityGlobal.fieldInfoInners[this.javaClass] = ConcurrentHashMap()
        }
    }

    protected inline fun <reified T> field(property: KProperty0<T>, column: String? = null, type: String = "",
                                           length: Int = 0, nullable: Boolean = false, defaultValue: String = "",
                                           primaryKey: Boolean = false, autoGenerated: Boolean = false): EntityField<T> {
        val propertyName = property.name
        var inner = EntityGlobal.fieldInfoInners[this.javaClass]!![propertyName]

        if (inner == null) {
            inner = EntityFieldInfo.Inner(property.name, column ?: property.name, type, length, nullable, defaultValue,
                    primaryKey, autoGenerated)
            EntityGlobal.fieldInfoInners[this.javaClass]!![propertyName] = inner
        }

        val info = EntityFieldInfo(this, inner)

        if (primaryKey) {
            primaryKeyFields.add(property)
            primaryKeyFieldInfos.add(info)
        }

        val f = EntityField(T::class, property, info)
        fieldMap[propertyName] = f

        return f
    }

    infix fun F(property: KProperty0<*>): EntityFieldInfo = fieldMap[property.name]!!.info

    fun assumeNoChange() {
        fieldMap.forEach { it.value.changed = false }
    }

    fun assumeAllChanged() {
        fieldMap.forEach { it.value.changed = true }
    }

    fun select() = EntityDSL.select(this).from()

    fun insert(): EntityInsertDSL<EntityModel> {
        assumeAllChanged()

        for ((i, v) in primaryKeyFieldInfos.withIndex()) {
            if (v.inner.dbAutoGenerated == true) {
                fieldMap[v.inner.name]!!.changed = false
            }
        }

        return EntityDSL.insert(this).values()
    }

    fun update() = EntityDSL.update(this)

    fun delete() = EntityDSL.delete(this)
}