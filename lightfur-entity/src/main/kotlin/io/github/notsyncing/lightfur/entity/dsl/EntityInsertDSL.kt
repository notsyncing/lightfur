package io.github.notsyncing.lightfur.entity.dsl

import io.github.notsyncing.lightfur.entity.EntityField
import io.github.notsyncing.lightfur.entity.EntityModel
import io.github.notsyncing.lightfur.sql.builders.InsertQueryBuilder
import io.github.notsyncing.lightfur.sql.builders.SelectQueryBuilder
import java.security.InvalidParameterException
import kotlin.reflect.KProperty

class EntityInsertDSL<F: EntityModel>(val insertModel: F) : EntityBaseDSL<F>(insertModel, isInsert = true) {
    override val builder = InsertQueryBuilder()

    init {
        val tableModel = getTableModelFromEntityModel(insertModel)
        builder.into(tableModel)

        for (info in insertModel.primaryKeyFieldInfos) {
            builder.returning(getColumnModelFromEntityField(info))
        }
    }

    fun select(query: EntitySelectDSL<*>): EntityInsertDSL<F> {
        insertModel.fieldMap.map { p -> getColumnModelFromEntityField(p.value) }
                .filter { c -> !c.isAutoGenerated }
                .sortedBy { it.fieldName }
                .forEach { c -> builder.column(c) }

        builder.select(query.toSQLPart() as SelectQueryBuilder)
        return this
    }

    fun values(data: EntityModel? = null, skips: List<KProperty<*>> = emptyList()): EntityInsertDSL<F> {
        val d = data ?: insertModel

        d.fieldMap.map { it }
                .sortedBy { it.key }
                .forEach {
                    val info = d.fieldMap[it.key]!!

                    if (info.dbAutoGenerated) {
                        return@forEach
                    }

                    if (skips.any { it.name == info.name }) {
                        return@forEach
                    }

                    var fieldValue = it.value.data

                    if ((!it.value.nullable) && (it.value.data == null)) {
                        if (it.value.defaultValue != null) {
                            fieldValue = it.value.defaultValue
                        } else if (it.value.defaultValueDefinedInDatabase) {
                            return@forEach
                        } else {
                            throw InvalidParameterException("Column ${it.key} " +
                                    "of entity ${d.javaClass} is non-nullable, " +
                                    "but neither a default value had been " +
                                    "defined in entity model, nor in database!")
                        }
                    }

                    builder.column(getColumnModelFromEntityField(info), fieldValue)
                }

        return this
    }

    fun skipExisting(): EntityInsertDSL<F> {
        builder.skipExisting()
        return this
    }

    fun updateWhenExists(column: EntityField<*>, alterOp: (EntityUpdateDSL<*>) -> Unit): EntityInsertDSL<F> {
        return updateWhenExists(listOf(column), alterOp)
    }

    fun updateWhenExists(columns: List<EntityField<*>>, alterOp: (EntityUpdateDSL<*>) -> Unit): EntityInsertDSL<F> {
        val updateDsl = EntityUpdateDSL(this, insertModel)
        updateDsl.skipTableName = true

        alterOp(updateDsl)

        if (requireTableAlias) {
            builder.withAlias()
        }

        val columnModels = columns.map { getColumnModelFromEntityField(it) }

        builder.whenExists(columnModels, updateDsl.toSQLPart())
        return this
    }
}